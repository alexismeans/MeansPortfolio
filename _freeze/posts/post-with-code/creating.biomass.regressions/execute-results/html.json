{
  "hash": "9d19fe55facfb3b91dd080a383d1b3af",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Creating Regression Equations\"\nauthor: \"Alexis Means\"\nformat:\n  html:\n    toc: true\n    toc-location: left\n    toc-depth: 3\n    code-fold: true\neditor: visual\n---\n\n\n\n## Data wrangling\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(readxl)\nlibrary(readr)\nlibrary(sf)\n\n#model dredging packages\nlibrary(caret)\nlibrary(recipes)\n\nsetwd(\"C:/Users/Alexis Means/Documents/Project/Nutrition Sampling/R code\")\n\n\n#2024 and 2025 observations\ndb <- \"C:/Users/Alexis Means/Documents/Project/Nutrition Sampling/VegDatabases/Working.composition.data.xlsx\"\nbiomass <- read_excel(db, \"Biomass\")\ncomp <- read_excel(db, \"Composition\")\ntransect <- read_excel(db, \"Transect\")\nplant <- read_excel(db, \"PlantList\")\n\n\n#Organizing and joining databases####\ncomp <- comp %>%\nmutate( Date = ymd(Date),\n        julian = yday(Date)\n) %>%\n  select(julian, PlotID, Quadrat, Spp, Percent, Pheno, Part)\n\n\nbiomass <- biomass %>%\n  rename(DryWeight = `DryWeight(g)`) %>%\n  select(PlotID, Quadrat, Spp, Pheno, Part, DryWeight)\n\n\n\ntransect_sf <- st_as_sf(transect,\n                        coords = c(\"BeginLong\", \"BeginLat\"),\n                        crs = 4326)   # WGS84 (lat/long)\ntransect_utm <- st_transform(transect_sf, crs = 32610)\ncoords <- st_coordinates(transect_utm)\n\ntransect <- transect %>%\n  mutate(BeginUTM_Easting = coords[,1],\n         BeginUTM_Northing = coords[,2]) %>%\n  select(PVT, PlotID, BeginUTM_Northing, BeginUTM_Easting)\n\n\n\nplant <- plant %>%\n  select(Spp, Family, Genus, Species, FG_New) %>%\n  rename(FunctionalGroup = FG_New)\n\n\n\n#create object for inorganic matter\nabiotic <- c(\"LITTER\",\"EARTH\", \"LICHEN\", \"WATER\", \"ROCKS\", \"DEADFALL\")\n\n\n#combining and creating an overall %cover for inorganic matter in each quadrat\ncomp <- comp %>%\n  group_by(PlotID, Quadrat) %>%\n  mutate(Abiotic.cover = sum(Percent[(Spp %in% abiotic)])) %>%\n  ungroup()\n\n\n#Left join biomass and comp by quadrat and plot_ID\ncomp <- comp %>%\n  left_join(y = biomass,\n            by = c(\"PlotID\", \"Quadrat\", \"Spp\", \"Pheno\", \"Part\"))\n\n\n#filtering out all quadrats where no biomass is recorded for the quadrat\n#filter out all of the abiotic observations\ncomp <- comp %>%\n  filter(!(Spp %in% abiotic)) %>%\n  filter(!is.na(DryWeight))\n\n\n## left join columns from plant list, comp, biomass and transect to keep the necessary columns\ncomp <- comp %>%\n  left_join(y = plant,\n            by = \"Spp\") %>%\n  left_join(y=transect,\n            by = \"PlotID\",\n            relationship = \"many-to-one\") #since there is multiple plotID duplicates this is necessary to join the transect database\n\n\ncomp <- comp %>%\n  select(julian, PVT, PlotID, Quadrat, Spp, Pheno, Part, Abiotic.cover,\n         DryWeight, Percent, Family, Genus, Species, FunctionalGroup, BeginUTM_Easting,\n         BeginUTM_Northing)\nView(comp)\n\n\n\n\n#Loading Covariates####\n#create empty list to load the covariates into\ncovariates <-  vector(mode = 'list')\n\n#List all the covariates that you want to use\ncovariates$asp <- rast(\"C:/Users/Alexis Means/OneDrive/OneDrive - University of Idaho/DocuMents/Project/Nutrition Sampling/Rasters/LF_Asp/LC20_Asp_220.tif\")\ncovariates$elev <- rast(\"C:/Users/Alexis Means/OneDrive/OneDrive - University of Idaho/DocuMents/Project/Nutrition Sampling/Rasters/LF_Elev/LC20_Elev_220.tif\")\n\n#can add more covariates here without updating for loop\n\n\n#make a shape object out of the coordinates that exist in comp\ncoords <- vect(comp,\n               geom = c(\"BeginUTM_Easting\",\"BeginUTM_Northing\"),\n               crs = \"EPSG:32610\")\n\n\n\n\n#create a for loop####\n#goes over each covariate raster that we have and\n#reprojecting the UTM points into the the same ESPG of the imported rasters\n\nfor (i in 1:length(covariates)){\n  proj.coords = project(x = coords,\n                        y = covariates[[i]])\n  out = extract(x = covariates[[i]],\n                y = proj.coords)\n  comp[,names(covariates[i])] = out [,2]\n}\n\n## THIS IS A CHECK IF YOU NEED IT\n# helps plot points to troubleshoot\ni = 1\nproj.coords <- project(x = coords,\n                       y = covariates[[i]])\n\nplot(covariates[[1]])\npoints(proj.coords, col = \"red\", pch = 16)\n\n\n#restructure df\ncomp <- comp %>%\n  select(PlotID, Spp, Family, Genus, DryWeight, Percent, julian, PVT, Abiotic.cover, elev, asp, FunctionalGroup)\n\n#If there are any 0 values it corrects them to 0.01\ncomp$DryWeight = ifelse(comp$DryWeight == 0, .01, comp$DryWeight)\n\n\n#make sure everything is being read the way we want it to\ncomp$elev = as.numeric(comp$elev)\ncomp$Family = as.factor(comp$Family)\ncomp$Genus= as.factor(comp$Genus)\ncomp$FunctionalGroup= as.factor(comp$FunctionalGroup)\ncomp$Spp= as.factor(comp$Spp)\ncomp$DryWeight= as.numeric(comp$DryWeight)\n\n\n#remove unnecessary objects from environment\nrm(i, transect, plant, biomass)\n\n#calculate sample size for each hierarchical group####\n#species\ncomp <- comp %>%\n  group_by(Spp) %>%\n  mutate(n.Species = sum(!is.na(Spp))) %>%\n  ungroup()\n\ncomp <- comp %>%\n  group_by(Genus) %>%\n  mutate(n.Genus = sum(!is.na(Genus))) %>%\n  ungroup()\n\ncomp <- comp %>%\n  group_by(Family) %>%\n  mutate(n.Family =  sum(!is.na(Family))) %>%\n  ungroup()\n\ncomp <- comp %>%\n  group_by(FunctionalGroup) %>%\n  mutate(n.FunctionalGroup = sum(!is.na(FunctionalGroup))) %>%\n  ungroup()\n\nmodel.y <- comp %>%\n  select( PVT, PlotID, Spp, Family, Genus,FunctionalGroup, DryWeight, n.Species, n.Genus, n.Family, n.FunctionalGroup)\nmodel.x <- comp %>%\n  select(Percent, julian, Abiotic.cover, elev, asp)\n```\n:::\n\n\n\n## Transform Covariates\n\n```{# {r}\n#| eval: false\n#Define covariate transformations\ntransformations = function(x) {\n  data.frame(\n    identity = x,\n    sin = sin(x),\n    cos = cos(x),\n    quadratic = x^2,\n    cubic = x^3,\n    log = ifelse(x > 0, log(x), NA),\n    sqrt = ifelse(x > 0, sqrt(x), NA)\n  )\n}\n\n\n#calculate transformed covariates\ntransform.covars = lapply(X = model.x,\n                          FUN = transformations)\ntransform.covars = do.call(cbind, transform.covars)\nView(transform.covars)\n\n#rename columns\ncolnames(transform.covars) = unlist(lapply(X = c(\"Percent\", \"julian\", \"Abiotic.cover\", \"elev\", \"asp\"),\n                                           FUN = function(var) {\n                                             paste0(var, '_', c('identity', 'sin', 'cos', 'quadratic', 'cubic', 'log', 'sqrt'))\n                                           }))\n\n\n\n#scale and center predictor variables\nmodel.x = transform.covars %>%\n  mutate(across(everything(), ~ (.-mean(.))/sd(.))) %>%\n  select_if(~ !any(is.na(.)))\n\n# Combine y and x (keeping transformed predictors)\ndf <- cbind(model.y, model.x)\n\n#write.csv(df, \"C:/Users/Alexis Means/Documents/Project/Nutrition Sampling/R code/biomass/processed.data/24and25.prepped.biomass.db\")\n```\n\n## Create Regression Equations\n\n### Species Level\n\n```{# {r}\n#| eval: false\n#select only species with 10 or more observations of biomass\nspecies.df <- df %>% filter(n.Species >= 10)\nspecies.df$Spp <- as.character(species.df$Spp)\nspecies.names <- unique(species.df$Spp)\nspecies.model.list <- list()\n\nfor(i in seq_along(species.names)) {\n  species.name <- species.names[i]\n\n  dat <- species.df %>% filter(Spp == species.name)\n\n  y <- dat$DryWeight\n  X <- dat[, colnames(model.x)]  # only use the predictors\n\n  # remove constant columns\n  X <- X[, apply(X, 2, sd) > 0]\n\n  # correlation filter\n  cor.matrix <- cor(X, use = \"pairwise.complete.obs\")\n  high.cor <- findCorrelation(cor.matrix, cutoff = 0.6)\n  X <- X[, -high.cor]\n\n  z <- cbind(y, X)\n\n  # fit model, dredge, select top model\n  gm <- lm(y ~ 0 + ., data = z, na.action = na.fail)\n  model.set <- dredge(global.model = gm,\n                      beta = 'sd',\n                      evaluate = TRUE,\n                      rank = 'AICc',\n                      m.lim = c(1,6),\n                      trace = FALSE)\n  best.model <- get.models(model.set, 1)[[1]]\n\n  # store with proper name\n  species.model.list[[species.name]] <- best.model\n\n  message(paste0(i, \"/\", length(species.names), \" Species Completed\"))\n}\n\nnames(species.model.list)\n\n#save R object for species regressions in case R crashes\n#saveRDS(species.model.list, 'C:/Users/Alexis Means/Documents/Project/Nutrition Sampling/R code/biomass/regression_equations/24and25-Biomass-Regression-Species-Top-Model-List.rds')\n\n#clean up global environment\nrm(z,gm,dat,best.model,model.set,species.df,i)\n```\n\n### Genus Equations\n\n```{# {r}\n#| eval: false\n#filter data\ngenus.df <- df %>%\n  filter(n.Genus >= 10)\n\ngenus.df$Genus <- as.character(genus.df$Genus)\n# create empty list\ngenus.model.list <- list()\n\n# get unique genera once\ngenus.names <- unique(genus.df$Genus)\n\n# loop through each genus\nfor(i in seq_along(genus.names)) {\n\n  genus.name <- genus.names[i]  # current genus\n  dat <- genus.df %>%\n    filter(Genus == genus.name)  # filter for this genus\n\n  y <- dat$DryWeight\n  X <- dat[, colnames(model.x)]\n\n  # remove columns with constant values\n  X <- X[, apply(X, 2, sd) > 0]\n\n  # create correlation matrix to identify correlated predictors\n  cor.matrix <- cor(X, use = \"pairwise.complete.obs\")\n  high.cor <- findCorrelation(cor.matrix, cutoff = 0.6)\n\n  # remove highly correlated columns\n  X <- X[, -high.cor]\n\n  # bind regression data\n  z <- cbind(y, X)\n  rm(cor.matrix, X, y, high.cor)\n\n  # fit global model\n  gm <- lm(y ~ 0 + ., data = z, na.action = na.fail)\n\n  # stepwise model selection\n  model.set <- dredge(global.model = gm,\n                      beta = 'sd',\n                      evaluate = TRUE,\n                      rank = 'AICc',\n                      m.lim = c(1,6),\n                      trace = FALSE)\n\n  # grab top model\n  best.model <- get.models(model.set, 1)[[1]]\n\n  # store best model with genus name\n  genus.model.list[[genus.name]] <- best.model\n\n  # print progress\n  message(paste0(i, \"/\", length(genus.names), \" Genera Completed\"))\n}\n\n# check names\nnames(genus.model.list)\n\n#save genus level regression data\n#saveRDS(genus.model.list, 'C:/Users/Alexis Means/Documents/Project/Nutrition Sampling/R code/biomass/regression_equations/24and25-Biomass-Regression-Genus-Top-Model-List.rds')\n\n#clean global environment\nrm(dat,genus.df,gm,model.set,z,best.model)\n```\n\n### Family Equations\n\n```{# {r}\n#| eval: false\n#filter data frame\nfamily.df = df %>%\n  filter(n.Family >= 10)\n\nfamily.df$Family <- as.character(family.df$Family)\n\n#create empty list\nfamily.model.list = list()\n\n# get unique genera once\nfamily.names <- unique(family.df$Family)\n\n\n# Family regression loop\nfor(i in seq_along(family.names)) {\n  family.name <- family.names[i]\n\n  # Filter for current family\n  dat <- family.df %>% filter(Family == family.name)\n\n  y <- dat$DryWeight\n  X <- dat[, colnames(model.x), drop = FALSE]\n\n  # Remove constant columns\n  X <- X[, apply(X, 2, sd) > 0, drop = FALSE]\n\n  # Correlation filter\n  cor.matrix <- cor(X, use = \"pairwise.complete.obs\")\n  high.cor <- findCorrelation(cor.matrix, cutoff = 0.6)\n  X <- X[, -high.cor, drop = FALSE]\n\n  # Bind regression data\n  z <- cbind(y, X)\n\n  # Fit model, dredge, select top model\n  gm <- lm(y ~ 0 + ., data = z, na.action = na.fail)\n  model.set <- dredge(global.model = gm,\n                      beta = 'sd',\n                      evaluate = TRUE,\n                      rank = 'AICc',\n                      m.lim = c(1,6),\n                      trace = FALSE)\n  best.model <- get.models(model.set, 1)[[1]]\n\n  # Store best model with proper name\n  family.model.list[[family.name]] <- best.model\n\n  # Print iteration\n  message(paste0(i, \"/\", length(family.names), \" Families Completed\"))\n}\n\nnames(family.model.list)\n\n#save genus level regression data\n#saveRDS(family.model.list, 'C:/Users/Alexis Means/Documents/Project/Nutrition Sampling/R code/biomass/regression_equations/24and25-Biomass-Regression-Family-Top-Model-List.rds')\n\n```\n\n### Functional Group Equations\n\n```{# {r}\n#| eval: false\n# filter data frame\nfunctional.group.df <- df %>%\n  filter(n.FunctionalGroup >= 10)\n\nfunctional.group.df$FunctionalGroup <- as.character(functional.group.df$FunctionalGroup)\n# create empty list\nfunctional.group.model.list <- list()\n\n# get unique functional groups once\nfg.names <- unique(functional.group.df$FunctionalGroup)\n\n\n# loop through each functional group\nfor(i in seq_along(fg.names)) {\n\n  fg.name <- fg.names[i]  # current functional group\n  dat <- functional.group.df %>%\n    filter(FunctionalGroup == fg.name)  # filter for this group\n\n  y <- dat$DryWeight\n  X <- dat[, colnames(model.x)]\n\n  # remove columns with constant values\n  X <- X[, apply(X, 2, sd) > 0]\n\n  # create correlation matrix to identify correlated predictors\n  cor.matrix <- cor(X, use = \"pairwise.complete.obs\")\n  high.cor <- findCorrelation(cor.matrix, cutoff = 0.6)\n\n  # remove highly correlated columns\n  X <- X[, -high.cor]\n\n  # bind regression data\n  z <- cbind(y, X)\n  rm(cor.matrix, X, y, high.cor)\n\n  # fit global model\n  gm <- lm(y ~ 0 + ., data = z, na.action = na.fail)\n\n  # stepwise model selection\n  model.set <- dredge(global.model = gm,\n                      beta = 'sd',\n                      evaluate = TRUE,\n                      rank = 'AICc',\n                      m.lim = c(1,6),\n                      trace = FALSE)\n\n  # grab top model\n  best.model <- get.models(model.set, 1)[[1]]\n\n  # store best model with functional group name\n  functional.group.model.list[[fg.name]] <- best.model\n\n  # print progress\n  message(paste0(i, \"/\", length(fg.names), \" Functional Groups Completed\"))\n}\n\n# check names\nnames(functional.group.model.list)\n\n#save genus level regression data\n#saveRDS(functional.group.model.list, \"C:/Users/Alexis Means/Documents/Project/Nutrition Sampling/R code/biomass/regression_equations/24and25-Biomass-Regression-Functional-Group-Top-Model-List.rds\")\n\n#clean up global environment\nrm(best.model,dat, family.df,gm,model.set,model.x,model.y,z,i)\n```\n",
    "supporting": [
      "creating.biomass.regressions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}